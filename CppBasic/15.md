## 面向对象编程（OOP）

对面向对象编程来说，一切都是对象，对象用类来描述

类把对象的数据和操作数据的方法作为一个整体考虑

定义类的语法：

```
class 类
{
public:
	类型1 成员1;
	类型2 成员2;
	...
}
```

注意：

* 类的成员可以是变量，也可以是函数
* 类的成员变量也叫属性
* 类的成员函数也叫方法，类的成员函数可以定义在类的外面
* 用类定义一个类的变量叫做创建一个对象
* 类的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。

## 类的访问权限

类的成员有三种访问权限：public, private 和 protected，分别表示公有的，私有的和受保护的

在类的内部，无论成员被声明为public 还是 private，都可以访问

在类的外部，只能访问public成员

在一个类体的定义中，private和public可以出现多次

结构体的成员默认为public，类的成员默认为private

private的意义在于隐藏类的数据和实现，把需要向外暴露的成员生命问public

## 构造函数和析构函数

构造函数：在创建对象时自动进行初始化工作

析构函数：在销毁对象前自动完成清理工作

#### 构造函数

语法`类(){...}`

* 访问权限必须是public
* 函数名必须与类名相同
* 没有返回值，也不写void
* 可以有参数，可以重载，可以有默认参数
* 创建对象时会自动调用一次，不能手工调用

#### 析构函数

语法：`~类(){...}`

* 访问权限必须是public
* 函数名必须在类名前加\~
* 没有返回值，也不写void
* 没有参数，不能重载
* 销毁对象前指挥自动调用一次，但是可以手工调用

## 构造函数的细节

* 如果没有提供构造/析构函数, 编译器将提供空的构造/析构函数
* 如果提供了构造/析构函数, 编译器将不提供空实现的构造/析构函数
* 创建对象的时候, 如果重载了构造函数, 编译器根据实参匹配相应的构造函数
* 创建对象的时候不要在对象名后面加圆括号, 编译器误以为是声明函数(没有构造函数, 构造函数没有参数, 构造函数的参数都有默认参数)
* 在构造函数名后面加括号和参数不是调用构造函数, 是创建匿名函数
* 接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值(可能会导致问题)
* 以下两行代码有本质区别:

```
m_class a = m_class("name", 10);	// 显示创建对象

m_class a;
a = m_class("name", 10);			// 创建匿名函数, 然后赋值给现有对象
```

* 用`new/delete`创建/销毁对象时, 也会调用构造/析构函数
* 不建议在构造/析构函数中写太多代码, 可以调用成员函数
* 除了初始化, 不建议让构造做太多工作
* 如果类的成员也是类, 创建对象的时候, 先构造成员类; 销毁对象的时候, 先析构成员类

## 拷贝构造函数

用一个已存在的对象创建新的对象, 不会调用构造函数, 而是调用拷贝构造函数

如果类中没有定义拷贝构造函数, 编译器将提供一个拷贝构造函数, 它的功能是把已存在的对象的成员变量赋值给新对象的成员变量

用一个已存在的对象创建新的对象的语法:

```
类名 新对象名(已存在的对象名);
类名 新对象名 = 已存在的对象名;
```

拷贝构造函数的语法:

`类名(const 类名& 对象名){...}`

注意:

* 访问权限必须是public
* 函数名必须与类名相同
* 没有返回值, 不写void
* 如果类中定义了拷贝构造函数, 编译器将不再提供拷贝构造函数
* 以值传递的方式调用函数时, 如果实参为对象, 会调用拷贝构造函数
* 函数以值的方式返回对象时, 可能会调用拷贝构造函数(VS会调用, Linux不会, g++做了优化)
* 拷贝构造函数可以重载, 可以有默认参数

```
类名(..., const 类名& 对象名, ...){...}
```

* 如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数, 编译器也会提供默认的拷贝构造函数

## 浅拷贝和深拷贝

浅拷贝对指针指向的地址直接复制，深拷贝复制指针指向的值，可以防止出现野指针或同时修改等问题

可以通过修改拷贝构造函数来使其改为深拷贝

## 初始化列表

构造函数的执行可以分成两个阶段：初始化阶段和计算阶段。初始化阶段先于计算阶段。

* 初始化阶段：全部的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。
* 计算阶段：一般是指用于执行构造函数体内的赋值操作。

初始化列表的语句：

```
类名(形参列表):成员1(值1), 成员2(值2)...
{...}
```

注意：

* 如果成员已经在初始化列表中，则不应该在构造函数中再次复制
* 初始化列表的括号中可以实具体的值，也可以是构造函数的形参名，还可以是表达式
* 初始化列表与赋值有本质区别，如果成员是类，使用初始化列表调用的是拷贝构造函数，而赋值则是先创建对象（调用普通构造函数），然后再赋值
* 如果成员是类，初始化列表对性能略有提升
* 如果成员是常量和引用，必须使用初始列表，因为常量和引用只能在定义的时候初始化
* 如果成员是没有默认构造函数的类，必须使用初始列表
* 拷贝构造函数也可以有初始化列表
* 类的成员变量可以不出现在初始化列表中