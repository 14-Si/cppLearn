## C++异常

* 异常的理念看似很有前途，但实际的使用效果并不好
* 编程社区达成的一致意见是，最好不要使用这项功能
* C++98引入异常规范，C++11已弃用

### 异常的语法

#### 捕获全部异常

```
try
{
	// 可能抛出异常的代码
	// throw 异常对象
}
catch(...)
{
	// 不管什么异常，都在这里统一处理
}
```

#### 捕获指定的异常

```
try
{
	// 可能抛出异常的代码
	// throw 异常对象
}
catch(exception1 e)
{
	// 发生exception1异常时的处理代码
}
catch(exception2 e)
{
	// 发生exception2异常时的处理代码
}
```



在try语句块中，如果没有发生异常，执行完try语句块中的代码后，将继续执行try语句块之后的代码；如果发生了异常，用throw抛出异常对象，异常对象的类型决定了应该匹配到哪个catch语句块，如果没有匹配到catch语句块，程序将调用abort()函数中止

如果try语句块中用throw抛出异常对象，并匹配到了catch语句块，执行完catch语句块中的代码后，将继续执行catch语句块之后的代码，不会回到try语句块中

如果程序中的异常没有被捕获，程序将异常终止

### 异常规范

C++ 98 标准提出了异常规范，目的是为了让使用者知道函数可能会引发哪些异常

```
void func1() throw(A, B, c);	// 表示该函数可能会抛出A，B，C类型的异常
void func2() throw();			// 表示该函数不会抛出异常
void func3();					// 该函数不符合C++ 98的异常规范
```

C++ 11 标准弃用了异常规范，使用新增的关键字noexcept指出函数不会引发异常

```
void func4() noexcept;			// 该函数不会抛出异常
```

在实际开发中，大部分程序员懒得在函数后面加noexcept，弃用异常已是共识，没必要多此一举

关键字noexcept也可以用作运算符，判断表达式（操作数）是否可能引发异常；如果表达式可能引发异常，则返回false，否则返回true

#### 重点异常

1. std::bad_alloc

   如果内存不足，调用new会产生异常，导致程序终止；如果在new关键字后面加std::nothrow选项，则会返回nullptr，不会产生异常

2. std::bad_cast

   dynamic_cast可以用于引用，但是没有与空指针对应的引用值，如果转换请求不正确，会出现std::bad_cast异常

3. std::bad_typeid

   假设有表达式typeid(*ptr)，当ptr指针为空时，如果ptr是多态的类型，将会引发std::bad_typeid异常

## C++断言

### 断言

断言（assertion）是一种常用的编程手段，用于排除程序中不应该出现的逻辑错误

使用断言需要包含头文件`<cassert>`或`<assert.h>`，头文件中提供了带参数的宏`assert`，用于程序在运行时进行断言

语法：`assert(表达式);`

断言就是判断(表达式)的值，如果为false，程序将调用abort()函数中止，如果是true，程序继续执行

断言可以提高程序的可读性，帮助程序员定位违反了某屑前提条件的错误。

注意：

* 断言用于处理程序中不应该发生的错误，而非逻辑上可能会发生的错误
* 不要把需要执行的代码放到断言的表达式中
* 断言的代码一般放在函数/成员函数的第一行，表达式多为函数的形参

### C++11 静态断言

assert宏是运行时断言，在程序运行时才能起作用

C++ 11 新增了静态断言`static_assert`，用于在编译时检查源代码

使用静态断言不需要包含头文件

语法；`static_assert(常量表达式,提示信息)`

注意：`static_assert`的第一个参数是常量表达式。而assert的表达式既可以是常量，也可以是变量