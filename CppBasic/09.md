## C++内存模型

代码段: 存放可执行代码, 常量

数据段: 存放全局变量和静态变量

堆区: 存放动态开辟的内存变量

栈区: 存放局部变量, 函数的参数以及返回值

**栈和堆的主要区别**

* 管理方式不同: 栈是编译器自动管理的, 在出作用域时, 将被自动释放; 堆需要手动释放, 若程序中不释放, 程序结束时由操作系统回收.
* 空间大小不同: 堆内存的大小受限于物理内存空间, 而栈一般只有 8M
* 分配方式不同: 堆是动态分配; 栈有静态分配和动态分配
* 分配效率不同: 栈是由系统提供的数据结构, 计算机在底层提供了对栈的支持, 进栈和出栈有专门的指令, 效率比较高; 堆是由C++函数库提供的.
* 是否产生碎片: 对于栈来说, 进栈和出栈都有着严格的顺序 (先进后出), 不会产生碎片; 堆频繁地分配和释放, 会造成内存空间的不连续, 容易产生碎片, 太多的碎片会导致性能的下降.
* 栈向下增长, 以降序分配内存地址; 堆向上增长, 以升序分配内存地址

## 动态分配内存 new 和 delete

使用堆区内存有四个步骤

1. 声明一个指针;

2. 用 new 运算符向系统申请一块内存, 让指针指向这块内存;
3. 通过对指针解引用的方式, 像使用变量一样使用这块内存;
4. 如果这块内存不用了, 要用 delete 运算符释放它.

语法:

```
new 数据类型(初始值);	// C++11支持{}
delete 地址;
```

如果new申请成功, 返回一个地址, 否则返回一个空地址

例子

```c++
#include <iostream>
using namespace std;

int main()
{
	int* p;
	p = new int(10);

	cout << "*p = " << *p << endl;
	*p = 8;
	cout << "*p = " << *p << endl;

	delete p;
	return 0;
}
/*-------------------------------------
输出:
*p = 10
*p = 8

*/
```

注意:

* 动态分配出来的内存, 没有变量名, 只能通过指向它的指针来操作内存中的数据
* 如果动态分配的内存不用了, 必须用 delete 释放它, 否则有可能用尽系统的内存
* 动态分配的内存空间生命周期与程序相同, 程序退出时, 如果没有释放, 系统将自动回收
* 就算指针的作用域已失效, 所指向的内存也不会释放
* 用指针跟踪已分配的内存时, 不能跟丢

## 二级指针

二级指针用于存放指针变量的地址

语法: `数据类型** 指针名`

使用指针由两个目的: 传递地址, 存放动态分配的内存地址

在函数中, 如果传递普通变量的地址, 形参用指针; 传递指针的地址, 形参用二级指针

例子

```c++
#include <iostream>
using namespace std;

int main()
{
	int* p = 0;
	int** pp = &p;
	*pp = new int(3);
	cout << "p = " << p << endl;		// p指向的地址
	cout << "*p = " << *p << endl;		// p指向的数据
	cout << "pp = " << pp << endl;		// pp指向的地址
	cout << "*pp = " << *pp << endl;	// pp指向的指针(p)
	cout << "**pp = " << **pp << endl;	// pp指向的指针指向的数据(*p)
	return 0;
}
/*-------------------------------------
输出:
p = 000001442EC9C810
*p = 3
pp = 0000003E9454FC58
*pp = 000001442EC9C810
**pp = 3

*/
```

## 空指针

0和NULL都可以表示空指针

声明指针后, 在赋值之前, 让它指向空, 表示没有指向任何地址.

#### 使用空指针的后果

如果对空指针解引用, 程序会崩溃

如果对空指针使用 delete 运算符, 系统会忽略该操作, 不会出现异常, 所以内存释放后, 应该将指针指向空

**在函数中, 应该由判断形参是否为空指针的代码, 目的是保证程序的健壮性**

空指针指向的区域一般使空闲的，对这段区域进行任何的读写操作都会引起异常

#### C++11的nullptr

用0和NULL表示空指针会产生歧义，C++11建议用nullptr表示空指针，也就是(void *)0。

**在LINUX平台下，如果使用nullptr，编译需要加-std=c++11参数**

## 野指针

野指针就是指针指向的不是一个有效（合法）的地址

在程序中，如果访问野指针，可能导致程序的崩溃

下面的情况可能会出现野指针：

1. 指针在定义时没有初始化
2. 指针指向了动态分配的内存，内存被释放后，指针没有置空
3. 指针指向的变量超越了变量的作用域

规避方法：

1. 指针在定义时，如果没有地方指，就初始化为nullprt
2. 动态分配内存被释放后，将其置为nullprt
3. 函数不要返回局部变量的地址

## 函数指针和回调函数

函数的二进制代码存放在内存区中的代码段，函数的地址是它在内存中的起始地址。如果把函数的地址作为参数，就可以在函数中灵活的调用其他函数。

使用函数指针的三个步骤：

1. 声明函数指针
2. 让函数指针指向函数地址
3. 通过函数指针调用函数

#### 声明函数指针

声明函数指针时，必须提供函数的类型，函数的类型是指返回值和参数列表，不包括函数名和形参名.

语法：`返回值 (*函数指针名)(形参数据类型);`

函数指针的返回值和参数列表要和原函数一样。

例子：

```c++
int func1(int bh, string str);
int func2(int no, string message);
int func3(int id, string info);

bool func4(int id, string info);

bool func5(int id);

int (*pfa)(int, string);
bool (*pfb)(int, string);
bool (*pfc)(int);
```

赋值语法：`函数指针名=函数名`

调用语法：

`函数指针名(参数);`(C++写法)

`(*函数指针名)(参数);`（C语言写法）

函数指针可以作为参数传递进其他函数。

例子：

```c++
#include <iostream>

using namespace std;

int mul(int a, int b)
{
	return a * b;
}

int sum(int a, int b)
{
	return a + b;
}

int calculator(int a, int b, int (*pfunc)(int, int))
{
	return (*pfunc)(a, b);
}

int main()
{
	int a = 4, b = 5;
	cout << "a * b = " << calculator(a, b, mul) << endl;
	cout << "a + b = " << calculator(a, b, sum) << endl;
	return 0;
}
/*--------------------------------------------------------------
输出：
a * b = 20
a + b = 9
*/
```

**回调函数在多线程和网络通讯中很常用**

