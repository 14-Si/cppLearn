## C++11 新标准

### long long 类型

新增了类型long long和unsigned long long，以支持64位或更快的整型

在VS中，int和long都是4字节，long long 是8字节

在Linux中，int是4字节，long 和 long long 是8字节

### char16_t 和 char32_t 类型

新增了类型char16_t和chat32_t以支持16位和32位的字符

### 原始字面量

### 统一的初始化（列表）

C++11丰富了大括号的适用范围，用大括号括起来的列表（统一的初始化列表）可以用于所有内置类型和用户自定义类型。使用统一的初始化列表，可以添加等号，也可以不添加：

```
int x = {5};
double y{2.75};
short quar[5]{1, 2, 3, 5, 7};
```

统一的初始化列表也可以用于new表达式中

`int *ar = new int[4]{2, 4, 6, 7};`

创建对象时，也可以使用大括号（而不是圆括号）来调用构造函数

STL容器提供了将initializer_list模板类作为参数的构造函数

头文件`<initializer_list>`提供了对模板类initialise_list的支持，这个类包含成员函数begin和end。除了用于构造函数外，还可以将initializer_list用于常规函数的参数

### 自动推导类型auto

### decltype 关键字

### 函数后置返回类型

### 模板的别名

### 空指针nullptr

空指针是不会指向有效数据的指针。以前，C/C++用0表示空指针，这带来一些问题，这样的话0既可以表示指针常量，又可以表示整型常量

C++新增了关键字nullptr，用于表示空指针，它是指针类型，不是整型类型

为了向后兼容，C++11仍允许用0来表示空指针，因此表达式nullptr==0为true

使用nullptr提供了更高的类型安全。例如，可以将0传递给形参为int的函数，但是，如果将nullptr传递给这样的函数，编译器将视为错误

因此，出于清晰和安全的考虑，请使用nullptr

### 智能指针

### 异常规范方面的修改

### 强类型枚举（枚举类）

传统的C++枚举提供了一种创建名称常量的方式，但其类型检查相当低级。另外，枚举名的作用域为枚举定义所属的作用域，这意味着如果在同一个作用域内定义两个枚举，它们的枚举成员不能同名。最后，枚举可能不是可完全移植的，因为不同的实现可能选择不同的底层类型。为解决这些问题，C++11新增了一种枚举。这种枚举使用class或struct定义

```
enum Old1{yes, no, maybe};
enum class New1 {never, sometimes, often, always};
enum struct New2 {never, lever, sever};
```

新枚举要求显式限定，以免发生名称冲突。因此，引用特定枚举时，需要使用New1::never和New2::never等。

强类型枚举默认的类型为int，也可以显式指定类型，具体做法是在枚举名后面加上type，type可以是除了wchar_t以外的任何整型

### explicit 关键字

C++支持对象自动转换，但是，自动类型转换可能导致意外。为了解决这种问题，C++11引入了explicit关键字，用于关闭自动转换的特性

### 类内成员初始化

在类的定义中初始化成员变量

### 基于范围的for循环

### 新的STL容器

1. array（静态数组）
2. forward_list（单向链表）
3. unordered_map, unordered_multimap, unordered_set, unordered_multiset（哈希表）

### 新的STL方法

1. C++11新增了方法cbegin，cend，crbegin，crend，这些方法将元素视为const
2. iterator emplace(iterator pos, ...)在指定位置插入一个元素，...用于构造元素，返回指向插入元素的迭代器
3. 除了传统的拷贝构造函数和赋值函数，C++11新增了移动构造函数和移动赋值函数

### 摒弃export

C++98新增了export关键字，C++11不再使用，但仍保留它作为关键字，供以后使用

### 嵌套模板的尖括号

为了避免与运算符>>混淆，C++要求声明嵌套模板时使用空格将尖括号分开

`vector<list<int> > v1`

C++11不再需要这样

`vector<list<int>> v2`

### final关键字

final关键字用于限制某个类不能被继承，或者某个虚函数不能被重写

final关键字放在类名或虚函数后面

### override关键字

在派生类中，把override放在成员函数的后面，表示重写基类的虚函数，提高代码的可读性

在派生类中，如果成员函数不是重写基类虚函数，加上override关键字编译器会报错

### 数值类型和字符串之间的转换

传统方法用sprintf和snprintf函数把数值转换为char\*字符串，用atoi，atol，atof函数把char\*字符串转换为数值

C++11提供了新的方法

1. 数值转换为字符串

   使用to_string函数可以将各种数值类型转拴换位string字符串类型，这是一个重载函数，在头文件`<string>`中声明

2. 字符转换为串数值

   在C++中，数值类型包括整型和浮点型，针对不同的数值类型提供了不同的函数在头文件`<string>`中声明

   ```
   int 				stoi(const string &str, size_t *pos = nullptr, int base = 10);
   long 				stol...
   long long 			stoll...
   unsigned long 		stoul...
   unsigned long long	stoull...
   float 				stof(const string &str, size_t *pos = nullptr);
   double 				stod...
   long double 		stold...
   ```

   形参说明：

   str	需要转换的string字符串

   pos	传出参数，存放从哪个字符开始无法继续解析的位置，例如123a1，传出的位置将3

   base	若 base 为0，则自动检测数值进制：若前缀为0，则为八进制，若前缀为0x或0X，则为十六进制，否则为十进制

### 静态断言

### 常量表达式constexpr

const关键字从功能上来说有双重语义：只读变量和修饰常量

C++11 标准为了解决 const 关键字的双重语义问题，保留了const表示“只读”的语义，而将“常量”的语义划分给了新添加的constexpr关键字

### 默认函数控制=default与=delete

在C++中自定义类，编译器会默认生成一些成员函数：

* 无参构造函数
* 拷贝构造函数
* 拷贝赋值函数
* 移动构造函数
* 移动赋值函数
* 析构函数

=default表示启用默认函数

=delete表示禁用默认函数

## 委托构造和继承构造

C++11标准新增了委托构造和继承构造两种方法，用于简化代码

### 委托构造

在实际开发中，为了满足不同的需求，一个类可能会重载多个构造函数。多个构造函数之间可能会有重复的代码。例如变量初始化，如果在每个构造函数中都写一遍，这样代码会显得臃肿

委托构造就是在一个构造函数的初始化列表中调用另一个构造函数

语法：`构造函数1(a, b, c) : 构造函数2(a, b)`

注意：

* 不要生成环状的构造过程
* 一旦使用委托构造，就不能在初始化列表中初始化其他的成员变量

### 继承构造

在 C++ 11之前，派生类如果要使用基类的构造函数，可以在派生类构造函数的初始化列表中指定

C++11推出了继承构造，在派生类中使用using来声明继承基类的构造函数

## lambda 函数

lambda 函数是C++11标准新增的语法糖，也成为lambda表达式或匿名函数

lambda函数的特点是：距离近，简洁，高效和功能强大

示例：`[](const int &no)->void{cout << "test:" << endl;};`

语法：

`捕获列表 参数列表 函数选项 返回类型 函数体`

### 参数列表

参数列表是可选的，类似普通函数的参数列表，如果没有参数列表，()可以省略不写

与普通函数不同

* lambda函数不能有默认参数
* 所有参数必须有参数名
* 不支持可变参数

### 返回类型

用后置的方法书写返回类型，类似于普通函数的返回类型，如果不写返回类型，lambda会根据函数体中的代码推断出来

如果有返回类型，建议显示的指定，自动推断可能与预期不一致

### 函数体

类似于普通函数的函数体

### 捕获列表

通过捕获列表，lambda函数可以访问的父作用域中的非静态局部变量（静态局部变量可以直接访问）

捕获列表在书写在[]中，与函数参数的传递类似，捕获方式也可以是值或者引用

以下列出了不同的捕获列表的方式

| []                   | 空捕获列表。lambda不能使用所在函数中的变量                   |
| -------------------- | ------------------------------------------------------------ |
| [name]               | names是一个逗号分隔符的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下是值捕获，名字前加&是引用捕获 |
| [=]                  | 隐式捕获列表，采用值捕获方式。lambda将拷贝所使用的来自所在函数的实体值 |
| [&]                  | 隐式捕获列表，采用引用捕获方式                               |
| [&, identifier_list] | identifier_list是一个逗号分隔符的名字列表,包含多个来自所在函数的变量。这些变量采用值捕获的该方式，其他隐式捕获的变量采用引用捕获 |
| [=, identifier_list] | identifier_list是一个逗号分隔符的名字列表,包含多个来自所在函数的变量。这些变量采用引用捕获的该方式，其他隐式捕获的变量采用值捕获，identifier_list中的名字不能包括this，且必须使用& |

如果要修改值捕获的变量的值，可以加mutable选项，但是在lambda函数的外部，变量的值不会被修改

`[a]()mutable {a++;};`