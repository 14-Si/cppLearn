## C++11 新标准

### long long 类型

新增了类型long long和unsigned long long，以支持64位或更快的整型

在VS中，int和long都是4字节，long long 是8字节

在Linux中，int是4字节，long 和 long long 是8字节

### char16_t 和 char32_t 类型

新增了类型char16_t和chat32_t以支持16位和32位的字符

### 原始字面量

### 统一的初始化（列表）

C++11丰富了大括号的适用范围，用大括号括起来的列表（统一的初始化列表）可以用于所有内置类型和用户自定义类型。使用统一的初始化列表，可以添加等号，也可以不添加：

```
int x = {5};
double y{2.75};
short quar[5]{1, 2, 3, 5, 7};
```

统一的初始化列表也可以用于new表达式中

`int *ar = new int[4]{2, 4, 6, 7};`

创建对象时，也可以使用大括号（而不是圆括号）来调用构造函数

STL容器提供了将initializer_list模板类作为参数的构造函数

头文件`<initializer_list>`提供了对模板类initialise_list的支持，这个类包含成员函数begin和end。除了用于构造函数外，还可以将initializer_list用于常规函数的参数

### 自动推导类型auto

### decltype 关键字

### 函数后置返回类型

### 模板的别名

### 空指针nullptr

空指针是不会指向有效数据的指针。以前，C/C++用0表示空指针，这带来一些问题，这样的话0既可以表示指针常量，又可以表示整型常量

C++新增了关键字nullptr，用于表示空指针，它是指针类型，不是整型类型

为了向后兼容，C++11仍允许用0来表示空指针，因此表达式nullptr==0为true

使用nullptr提供了更高的类型安全。例如，可以将0传递给形参为int的函数，但是，如果将nullptr传递给这样的函数，编译器将视为错误

因此，出于清晰和安全的考虑，请使用nullptr

### 智能指针

### 异常规范方面的修改

### 强类型枚举（枚举类）

传统的C++枚举提供了一种创建名称常量的方式，但其类型检查相当低级。另外，枚举名的作用域为枚举定义所属的作用域，这意味着如果在同一个作用域内定义两个枚举，它们的枚举成员不能同名。最后，枚举可能不是可完全移植的，因为不同的实现可能选择不同的底层类型。为解决这些问题，C++11新增了一种枚举。这种枚举使用class或struct定义

```
enum Old1{yes, no, maybe};
enum class New1 {never, sometimes, often, always};
enum struct New2 {never, lever, sever};
```

新枚举要求显式限定，以免发生名称冲突。因此，引用特定枚举时，需要使用New1::never和New2::never等。

强类型枚举默认的类型为int，也可以显式指定类型，具体做法是在枚举名后面加上type，type可以是除了wchar_t以外的任何整型

### explicit 关键字

C++支持对象自动转换，但是，自动类型转换可能导致意外。为了解决这种问题，C++11引入了explicit关键字，用于关闭自动转换的特性

### 类内成员初始化

在类的定义中初始化成员变量

### 基于范围的for循环

### 新的STL容器

1. array（静态数组）
2. forward_list（单向链表）
3. unordered_map, unordered_multimap, unordered_set, unordered_multiset（哈希表）

### 新的STL方法

1. C++11新增了方法cbegin，cend，crbegin，crend，这些方法将元素视为const
2. iterator emplace(iterator pos, ...)在指定位置插入一个元素，...用于构造元素，返回指向插入元素的迭代器
3. 除了传统的拷贝构造函数和赋值函数，C++11新增了移动构造函数和移动赋值函数

### 摒弃export

C++98新增了export关键字，C++11不再使用，但仍保留它作为关键字，供以后使用

### 嵌套模板的尖括号

为了避免与运算符>>混淆，C++要求声明嵌套模板时使用空格将尖括号分开

`vector<list<int> > v1`

C++11不再需要这样

`vector<list<int>> v2`

### final关键字

final关键字用于限制某个类不能被继承，或者某个虚函数不能被重写

final关键字放在类名或虚函数后面

### override关键字

在派生类中，把override放在成员函数的后面，表示重写基类的虚函数，提高代码的可读性

在派生类中，如果成员函数不是重写基类虚函数，加上override关键字编译器会报错

### 数值类型和字符串之间的转换

传统方法用sprintf和snprintf函数把数值转换为char\*字符串，用atoi，atol，atof函数把char\*字符串转换为数值

C++11提供了新的方法

1. 数值转换为字符串

   使用to_string函数可以将各种数值类型转拴换位string字符串类型，这是一个重载函数，在头文件`<string>`中声明

2. 字符转换为串数值

   在C++中，数值类型包括整型和浮点型，针对不同的数值类型提供了不同的函数在头文件`<string>`中声明

   ```
   int 				stoi(const string &str, size_t *pos = nullptr, int base = 10);
   long 				stol...
   long long 			stoll...
   unsigned long 		stoul...
   unsigned long long	stoull...
   float 				stof(const string &str, size_t *pos = nullptr);
   double 				stod...
   long double 		stold...
   ```

   形参说明：

   str	需要转换的string字符串

   pos	传出参数，存放从哪个字符开始无法继续解析的位置，例如123a1，传出的位置将3

   base	若 base 为0，则自动检测数值进制：若前缀为0，则为八进制，若前缀为0x或0X，则为十六进制，否则为十进制

### 静态断言

### 常量表达式constexpr

const关键字从功能上来说有双重语义：只读变量和修饰常量

C++11 标准为了解决 const 关键字的双重语义问题，保留了const表示“只读”的语义，而将“常量”的语义划分给了新添加的constexpr关键字

### 默认函数控制=default与=delete

在C++中自定义类，编译器会默认生成一些成员函数：

* 无参构造函数
* 拷贝构造函数
* 拷贝赋值函数
* 移动构造函数
* 移动赋值函数
* 析构函数

=default表示启用默认函数

=delete表示禁用默认函数

## 委托构造和继承构造

C++11标准新增了委托构造和继承构造两种方法，用于简化代码

### 委托构造

在实际开发中，为了满足不同的需求，一个类可能会重载多个构造函数。多个构造函数之间可能会有重复的代码。例如变量初始化，如果在每个构造函数中都写一遍，这样代码会显得臃肿

委托构造就是在一个构造函数的初始化列表中调用另一个构造函数

语法：`构造函数1(a, b, c) : 构造函数2(a, b)`

注意：

* 不要生成环状的构造过程
* 一旦使用委托构造，就不能在初始化列表中初始化其他的成员变量

### 继承构造

在 C++ 11之前，派生类如果要使用基类的构造函数，可以在派生类构造函数的初始化列表中指定

C++11推出了继承构造，在派生类中使用using来声明继承基类的构造函数

## lambda 函数

lambda 函数是C++11标准新增的语法糖，也成为lambda表达式或匿名函数

lambda函数的特点是：距离近，简洁，高效和功能强大

示例：`[](const int &no)->void{cout << "test:" << endl;};`

语法：

`捕获列表 参数列表 函数选项 返回类型 函数体`

### 参数列表

参数列表是可选的，类似普通函数的参数列表，如果没有参数列表，()可以省略不写

与普通函数不同

* lambda函数不能有默认参数
* 所有参数必须有参数名
* 不支持可变参数

### 返回类型

用后置的方法书写返回类型，类似于普通函数的返回类型，如果不写返回类型，lambda会根据函数体中的代码推断出来

如果有返回类型，建议显示的指定，自动推断可能与预期不一致

### 函数体

类似于普通函数的函数体

### 捕获列表

通过捕获列表，lambda函数可以访问的父作用域中的非静态局部变量（静态局部变量可以直接访问）

捕获列表在书写在[]中，与函数参数的传递类似，捕获方式也可以是值或者引用

以下列出了不同的捕获列表的方式

| []                   | 空捕获列表。lambda不能使用所在函数中的变量                   |
| -------------------- | ------------------------------------------------------------ |
| [name]               | names是一个逗号分隔符的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下是值捕获，名字前加&是引用捕获 |
| [=]                  | 隐式捕获列表，采用值捕获方式。lambda将拷贝所使用的来自所在函数的实体值 |
| [&]                  | 隐式捕获列表，采用引用捕获方式                               |
| [&, identifier_list] | identifier_list是一个逗号分隔符的名字列表,包含多个来自所在函数的变量。这些变量采用值捕获的该方式，其他隐式捕获的变量采用引用捕获 |
| [=, identifier_list] | identifier_list是一个逗号分隔符的名字列表,包含多个来自所在函数的变量。这些变量采用引用捕获的该方式，其他隐式捕获的变量采用值捕获，identifier_list中的名字不能包括this，且必须使用& |

如果要修改值捕获的变量的值，可以加mutable选项，但是在lambda函数的外部，变量的值不会被修改

`[a]()mutable {a++;};`8

## 右值引用

在C++中所有的值不是左值，就是右值，左值是指表达式结束后依然存在的持久化对象，右值是值表达式结束后不再存在的临时对象。有名字的对象都是左值，右值没有名字

还有一个可以区分左值和右值的便捷方法：看能不能对表达式取地址，如果能，则为左值，否则为右值

C++11扩展了右值的概念，将右值分为了纯右值和将亡值

* 纯右值：
  1. 非引用返回的临时变量
  2. 运算表达式产生的结果
  3. 字面常量（C风格字符串除外，它是地址）
* 将亡值：与右值引用相关的表达式，例如：将要被移动的对象，T&&函数返回的值，std::move()的返回值，转换成T&&的类型的转换函数的返回值

不同纯右值和将亡值的区别其实没关系，统一看作右值即可，不影响使用

### 左值引用，右值引用

C++ 98 中的引用很常见，就是给变量取个别名，在C++11中，因为增加了右值引用的概念，所以C++98中的引用都称为左值引用

右值引用就是给右值取个别名，使用的符号是&&

语法：`数据类型 &&变量名 = 右值`

getTemp()返回值本来在表达式语句结束后其声明也就该结束了（因为是临时变量），而通过右值引用重获新生，其生命周期与右值引用类型变量的生命周期一样，只要aa还活着，该右值临时变量会一直存活下去。实际就是给那个临时变量取了个名字

引用右值引用的主要目的是实现移动语义

左值引用只能绑定左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。

但是，常量左值引用却不一样，它可以算是一个万能的引用类型，它可以绑定非常量左值，常量左值，右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命周期延长，缺点是只能读不能改

## 移动语义

如果一个对象中有堆区资源，需要编写拷贝构造函数和赋值函数，实现深拷贝

深拷贝把对象中的堆区资源复制了一份，如果源对象（被拷贝的对象）是临时对象，拷贝完就没什么用了，这样会造成没有什么意义的资源申请和释放操作。如果能够直接使用源对象拥有的资源，可以节省资源申请和释放的时间。C++新增加的移动语义就能够做到这一点

实现移动语义要增加两个函数：移动构造函数和移动赋值函数

移动构造函数的语法：

`类名(类名&& 源对象){...}`

移动赋值函数的语法：

`类名& operator=(类名 &&源对象){...}`

注意：

1. 对于一个左值，会调用拷贝构造函数，但有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？C++11为了解决这个问题，提供了std::move方法来讲左值转义为右值，从而方便使用移动语义，它其实就是告诉编译器，虽然是一个左值，但不要对其使用拷贝构造函数，使用移动构造函数。左值对象被转移资源后，不会立即析构，只有在离开自己作用域的时候才会析构，如果继续使用左值中的资源，可能会发生错误
2. 如果没有移动构造函数/移动赋值函数，只提供了拷贝构造函数和拷贝赋值函数，编译器会自动寻找后者
3. C++11中所有容器都实现了移动语义，避免对含有资源的对象发生无所谓的拷贝
4. 移动语义对于拥有资源（如内存，文件语柄）的对象有效，如果是基本类型，使用移动语义没有意义

## 完美转发

在函数模板中，可以将自己的参数“完美”地转发给其他函数。所谓完美，不仅能准确地转发参数的值，还能保证被转发参数的左，右值属性不变。

C++11标准引入了右值引用和移动语义，所以，能否实现完美转发，决定了该参数在传递过程使用的是拷贝语义还是移动语义

为了支持完美转发，C++11提供了以下方案：

1. 如果函数模板的参数类型为T&&，C++可以准确地判定出实际传入的实参是左值还是右值


2. 提供了模板函数`std::forward<T>(参数)`，用于转发参数，如果参数是一个右值，转发之后仍是右值引用，如果参数是一个左值，转发之后仍是左值引用

      ```
   template<typename T>
   void func(T&& arg)
   {
   	func1(forward<T>(arg));
   }
   ```

## 可变参数模板

可变参数模板是C++11新增的最强大的特性之一，它对参数进行了泛化，能支持任意个数，任意数据类型的参数

```
void func()
{
    cout << "Finish" << endl;
}

template<typename T, typename... Args>
void func(T arg, Args... args)
{
    cout << sizeof...(args) << ": " << arg << endl;
    func(args...);
}

int main()
{
    func(1, 2, 3, -1);
    return 0;
}
```

