## 友元

如果要访问类的私有成员变量，调用类的公有成员函数是唯一方法，而类的私有成员函数则无法访问

友元提供了另一访问类的私有成员的方案。友元有三种：

* 友元全局函数
* 友元类
* 友元成员函数

1. 友元全局函数

   在友元全局函数中，可以访问另一个类的所有成员

   ```
   class m_class
   {
   	friend int main();	// 设置main函数为友元函数
   public:
   	string name;
   	m_class(){};
   	void show_name()
   	{
   		cout << name << endl;
   	}
   private:
   	int age;
   	void show_age()
   	{
   		cout << age << endl;
   	}
   }
   ```

   

2. 友元类

   在友元类所有成员函数中，可以访问另一个类的所有成员

   ```
   class m_class
   {
   	friend class m_class_2;	// 设置m_class_2为友元类
   public:
   	string name;
   	m_class(){};
   	void show_name()
   	{
   		cout << name << endl;
   	}
   private:
   	int age;
   	void show_age()
   	{
   		cout << age << endl;
   	}
   }
   ```

   

   友元类的注意事项：

   * 友元关系不能被继承
   * 友元关系是单向的，不具备交换性

   

3. 友元成员函数

   在友元类某成员函数中，可以访问另一个类的所有成员。

   如果要把A的某成员函数声明为B的友元，声明和定义如下：

   ```
   class B;
   class A{...};
   class B{...};
   
   void B::func(A &i){...}
   ```

   

## 运算符重载

C++ 将运算符重载扩展到自定义的数据类型，它可以让对象操作更美观

例如字符串string用加号拼接，cout用两个尖括号输出

运算符重载的语法：

`返回值 operator运算符(参数列表)`

运算符重载函数的返回值要与运算符本身的含义一致

非成员函数版本的重载运算符函数：形参个数与运算符的操作个数相同

成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中的一个操作数隐式传递了调用对象

注意：

* 返回自定义数据类型的引用可以让多个运算符表达式串联起来（不要返回局部变量的引用）
* 重载函数参数列表中顺序决定了操作数的位置
* 重载函数的参数列表中至少有一个是用户自定义的类型，防止程序员为内置数据类型重载运算符
* 如果运算符重载既可以是成员函数也可以是全局函数，应该优先考虑成员函数，这样更符合运算符重载的初衷
* 重载函数不能违背运算符原来的含义和优先级
* 不能创建新的运算符

### 关系运算符

重载关系运算符（==, !=, >, <, >=, <=）用于比较两个自定义数据类型的大小

可以使用非成员函数和成员函数两种版本，建议采用成员函数版本

### 重载左移运算符

重载左移运算符（<<）用于输出自定义对象的成员变量，在实际开发中很有价值（调试和日志）

只能使用非成员函数版本

如果要输出对象的私有成员，可以配合友元一起使用

### 重载下标运算符

如果对象中有数组，重载下标运算符[]，操作对象中的数组将像操作普通数组一样方便

下标运算符必须以成员函数的形式进行重载

下标运算符重载函数的语法：

`返回值类型 &operator[](参数);`

或者：

`const 返回值类型 &operator[](参数) const;`

使用第一种声明方式， []不仅可以访问数组元素，还可以修改数组元素

使用第二种声明方式， []只能访问而不能修改数组元素

在实际开发中，我们应该同时提供以上两种形态，这样做是为了适应const对象，因为通过const对象只能调用const成员函数，如果不提供第二种形式，那么将无法访问const对象的任何数组元素

在重载函数中，可以对下标做合法性检查，防止数组越界

### 重载赋值运算符

C++ 编译器可能会给类添加四个函数

* 默认构造函数，空实现
* 默认析构函数，空实现
* 默认拷贝构造函数，队成员变量进行浅拷贝
* 默认赋值函数，对成员变量进行浅拷贝

对象的赋值运算是用一个已经存在的对象，给另一个已经存在的对象赋值

如果类的定义中没有重载赋值函数，编译器就会提供一个默认赋值函数

如果类中重载了赋值函数，编译器将不提供默认赋值函数

重载赋值函数的语法：`类名 &operator=(const 类名 &源对象)`

注意：

* 编译器提供的默认赋值函数，是一种浅赋值行为
* 如果对象中不存在堆区内存空间，默认重载赋值函数可以满足需求，否则需要深复制
* 赋值运算和拷贝构造不同，拷贝构造是指原来的对象不存在，用已存在的对象进行构造；赋值运算是用一个已经存在的对象，给另一个已经存在的对象赋值

### 重载new和delete运算符

重载 new 和 delete 运算符的目的是为了自定义内存分配的细节。（内存池：快速分配和归还，无碎片）

在C++中，使用 new 时，编译器做了两件事情

* 调用标准库函数 `operator new()`分配内存
* 调用构造函数初始化内存

使用delete的时候，编译器也做了两件事情

* 调用析构函数
* 调用标准库函数 `operator delete()` 释放内存

构造函数和析构函数由编译器调用，我们无法控制

但是，可以重载内存分配函数`operator new()` 和释放函数 `operator delete()`

* 重载内存分配函数的语句：`void* operator new(size_t size)`

  参数必须是size_t，返回值必须是void*

* 重载内存释放函数的语句: `void operator delete(void* ptr)`

  参数必须是void* （指向分配的内存），返回值必须是void

重载的new 和 delete 可以是全局函数，也可以是类的成员函数

为一个类重载 new 和 delete 时，尽管不必显式地使用 static ，但实际上仍在创建 static 成员函数

编译器看到使用 new 创建自定义类的对象时，他选择成员版本的operator new而不是全局版本的new

new[]和delete[]也可以重载

### 内存池

预先分配一大块的内存空间

提升分配和归还的速度

减少内存碎片

通常用在高性能服务器开发中

定义静态方法分配连续大块内存空间

```
static char* m_pool; // 内存池起始地址
    static bool init_pool()
    {
        m_pool = (char *)malloc(18);
        if (m_pool == 0)
            return false;
        memset(m_pool, 0, 18);
        return true;
    }
    static void free_pool()
    {
        if (m_pool == 0)
            return;
        free(m_pool);
    }
```

### 重载括号运算符

重载括号运算符，对象名可以当成函数来使用（函数对象，仿函数）

括号运算符重载的语法：

`返回值类型 operator()(参数列表)`

注意：

* 括号运算符必须以成员函数的形式进行重载
* 括号运算符重载函数具备普通函数的全部特征
* 如果函数对象与全局函数同名，按作用域规则选择调用的函数

函数对象的用途：

* 表面像函数，部分场景中可以替代函数，在 STL 中得到广泛的应用
* 函数对象的本质是类，可以用成员变量存放更多的信息
* 函数对象有自己的数据类型
* 可以提供继承体系

### 重载一元运算符

可重载的一元运算符

| 符号 | 作用       |
| ---- | ---------- |
| ++   | 自增       |
| --   | 自减       |
| ！   | 逻辑非     |
| &    | 取地址     |
| ~    | 二进制反码 |
| *    | 解引用     |
| +    | 一元加     |
| -    | 一元求反   |

一元运算符通常出现在它们所操作的对象的左边

但是自增运算符和自减运算符有前置和后置的区别

为了解决这个问题，C++规定，重载++和--时，允许写一个增加了int形参的版本，编译器处理后置表达式