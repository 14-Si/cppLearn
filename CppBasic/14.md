## 各种形参的使用场景

* 如果不需要在函数中修改实参
  * 如果实参很小，如内置数据类型或小型结构体，则按值传递
  * 如果实参是数组，则使用 const 指针，因为这是唯一的选择（没有为数组建立引用的说法）
  * 如果实参是较大的结构，则使用 const 指针或 const 引用
  * 数据实参是类，则使用 const 引用，传递类的标准方式是按引用传递（类设计的寓意经常要求使用引用）
* 如果需要在函数中修改实参
  * 如果实参是内置数据类型，则使用指针。只要看到 fun(&x) 的调用，表示函数将修改 x
  * 如果实参是数组，则只能使用指针
  * 数据实参是结构体，则使用指针或引用
  * 数据实参是类，则使用引用

## 函数的默认参数

默认参数是指调用函数的时候,如果不书写实参,那么将使用的一个默认值

语法:  `返回值 函数名(数据类型 参数=值, 数据类型 参数=值...);`

注意:

* 如果函数的声明和定义是分开写的,在函数声明中书写默认参数,函数的定义中不能书写默认参数.
* 函数必须从右向左设置默认参数.也就是说,如果要为某个参数设置默认值,则必须为他右边所有的参数提供默认值
* 调用函数的时候,如果制定了某个参数的值,那么该参数前面所有的参数都必须指定

## 函数重载

函数重载(函数多态)是指设计一系列同名函数,让他们完成相同(似)的工作

C++ 允许定义名称相同的函数, 条件是他们的特征(形参的个数, 数据类型和排列顺序) 不同.

```
int func(int a, string b);
int func(int a, string b, int len);
int func(string b, int len);
```

调用重载函数的时候, 在代码中我们用相同的函数名, 但是, 后面的实参不一样, 编译器根据实参与重载函数的形参进行匹配, 然后决定调用具体的函数,如果匹配失败, 编译器将视为错误

在实际开发中,视需求重载各种数据类型, 不要重载功能不同的函数.

注意:

* 使用重载函数时, 如果数据类型不匹配, C++尝试使用类型转换与形参进行匹配,如果转换后有多个函数能匹配上, 编译将报错
* 引用可以作为函数重载的条件,但是, 调用重载函数的时候, 如果实参是变量,编译器形参类型的本身和类型引用视为同一特征
* 如果重载函数有默认参数, 调用函数时, 可能导致匹配失败
* `const` 不能作为函数重载的特征
* 返回值不能作为函数重载的特征

## 内联函数

语法: 在声明和定义函数时, 在前面加上 `inline` 关键字, 函数就成为了内联函数

普通的函数调用是内存跳转的过程, 而内联函数则是将函数体嵌入到代码内的过程, 所以内联函数的调用速度要更快, 但是要占用更多的内存.

注意:

* 普通函数的声明和定义一般是分开的, 但内联函数的声明和定义一般写在一起

* 内联函数节省时间, 但是消耗内存
* 如果函数过大, 编译器可能不将其作为内联函数
* 内联函数不能递归