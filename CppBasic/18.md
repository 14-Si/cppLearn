## 自动类型转换

对于内置的类型，如果两种数据类型是兼容的，C++可以自动转换，如果从更大的数转换为更小的数，可能会被截断或损失精度

```
long count = 8;
double time = 11;
int side = 3.33;
```

C++不自动转换不兼容的类型，下面语句是非法的

`int* ptr = 8`

不能自动转换时，可以使用强制类型转换

`int* ptr = (int*)8;`

如果某种类型与类相关，从某种类型转换为类类型是有意义的

`string str = "123123123";`

在C++中，一个参数的构造函数为将该类型与该参数相同的值转换为类提供了蓝图。这一过程称为隐式转换，它是自动进行的，不需要显示强制类型转换

1. 一个类可以有多个转换函数

2. 多个参数的构造函数，除第一个参数外，如果其他参数都有默认值，也可以作为转换函数

3. 如果自动转换有二义性，编译将报错

   将构造函数用作自动类型转换函数似乎是一项不错的特性，但有时候会导致意外的类型转换，explicit关键字用于关闭这种自动特性，但仍允许显示转换

```
explicit int_pair(int a);
int_pair a = 1;				// false
int_pair a = int_pair(1);	// true
```

在实际开发中，如果强调的是构造，建议使用explicit，如果强调的是类型转换，则不使用explicit

## 转换函数

构造函数指用于从某种类型到类类型的转换，如果要进行相反的转换，可以使用特殊的运算符函数——转换函数

`operator 数据类型()`

转换函数必须是类的成员函数；不能指定返回值的类型，不能有参数

可以让编译器决定选择转换函数（隐式转换），可以像使用强制类型转换那样使用它们（显示转换）

如果隐式转换存在二义性，编译器将报错

在C++98中，关键字 explicit 不能用于转换函数，C++11中消除了这种限制，可以将转换函数声明为显示的

还有一种方法是：用一个功能相同的普通成员函数代替转换函数，普通成员函数只有被调用时才会执行

**应谨慎使用隐式转换函数。通常，最好选择仅在被显示调用时才会执行的成员函数**

