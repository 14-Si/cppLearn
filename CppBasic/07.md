## C++基本数据类型

### 整型

c++用 int 关键字来声明整型变量

在声明整型变量的时候,可以在int关键字之前加 signed, unsigned, short, long 四种修饰符.

**signed**: 有符号的

**unsigned**: 无符号的

**short**: 短的, 取值范围小

**long**: 长的, 取值范围大

根据内存大小判断取值范围: 

1. 一个字节有8位二进制位,能表示 2^8^ 个数
2. 假设数据类型有k个字节,则能表示 2^8*k^ 个数,有符号类型一般表示为[-2^4*k^, 2^4*k^ - 1], 无符号类型一般表示为[0, 2^8*k^ - 1]

#### 二进制

二进制由0和1两个数字组成.书写时要以0b或者0B开头

例子

```c++
int a = 0b101;
int b = -0b110010;
int c = 0B100001;
```

#### 八进制

八进制由0~7八个数字组成,书写时必须以0开头 (在Linux系统下,设备的权限都是用八进制来表示的)

例子

```c++
int a = 015;
int b = -0101;
int c = 0177777;
```

#### 十六进制

十六进制由0 ~ 9十个数字和 a ~ f (不区分大小写) 六个字母组成, 书写时以0x开头.

例子

```c++
int a = 0x2a;
int b = 0x3f;
int c = 0xffff;
```

#### long long

在 VS 中, long 是4字节, 32位.

在 Linux 中, long 是8字节, 64位.

C++11 标准新增了long long类型的整数, 至少64位, 且至少与 long 一样长

### 浮点型

C++ 浮点数分为三种: float(单精度), double(双精度), long double(扩展精度)

三者表示的有效数字范围不同

| 数据类型    | 占用空间      | 有效数字范围  |
| ----------- | ------------- | ------------- |
| float       | 4字节         | 7位           |
| double      | 8字节         | 15~16位       |
| long double | 不少于 double | 不低于 double |

**注意**

在 VS 和 Linux 中, long double 占用的内存分别为 8 和 16 字节

有效数字包括了小数点前后的数字.

C++ 默认显示 6 位有效数字, 可以用printf()函数来输出具体的位数

### 字符型

字符型 (char) 占用的内存空间是1个字节, 书写用单引号包含

在内存中, 不存放字符本身, 而是存放与它对应的编码, 即 ASCII 码

字符本质是整数, 也可以参与运算, 比如

```c++
char a = '0';
char b = '9';
int c = b - a;
cout << c << endl;
```

上面的程序会输出 9.

#### 转义字符

在C++中, 使用转义字符的原因有两个:

* 控制字符没有符号, 无法书写, 只能用其他符号代替.
* 某些符号已被 C++ 征用, 语义冲突, 只能用其他符号代替.

| ASCII 码 | 转义字符 | 含义                           |
| -------- | -------- | ------------------------------ |
| 0        | \0       | 空                             |
| 10       | \n       | 换行, 将当前位置移到下一行开头 |
| 13       | \r       | 回车, 将当前位置移到本行开头   |
| 9        | \t       | 水平制表(TAB)                  |
| 92       | \\\\     | 斜线'\\'                       |
| 34       | \\"      | 双引号, 书写字符时不必转义     |
| 39       | \\'      | 单引号, 书写字符串中不必转义   |

#### 原始字面量

在字符串前加R, 在后面的字符串处加"()"可以不使用

例子

```c++
#include <iostream>
using namespace std;

int main()
{
	string path_01 = "C:\tall";
	string path_02 = "C:\\tall";
	string path_03 = R"(C:\tall)";
	cout << path_01 << endl << path_02 << endl << path_03;
	return 0;
}
/*------------------------------------------
输出:
C:      all
C:\tall
C:\tall
*/
```

字符串的多行书写可以用'\\'作为连接符.

### 布尔型(bool)

0为假(false)

1为真(true)

布尔型占用1字节内存, 取值范围一般为0和1, 但可以通过直接修改内存的方式改为0~255, 本质上等同于unsigned char.

## C++字符串

C++风格字符串: `string 变量名 = "内容";`

C风格字符串: `char 变量名[] = "内容";`

后者本质为字符数组, 前者本质是类, 它封装了C风格字符串.

**C++风格字符串常用操作:**

* 赋值 `变量名 = "内容";`
* 拼接 `变量名 = 变量名 + "内容";`

字符串间可以用 "==" , "!=" 来判断内容是否相同.

例子

```c++
#include <iostream>
using namespace std;

int main()
{
	string name = "Christina";
	cout << "name: " + name << endl;
	return 0;
}
/*-------------------------------------------------
输出:
name: Christina

*/
```

## 数据类型的转换

#### 自动类型转换

某些类型的转换编译器可以隐式地进行, 不需要程序员干预.

不同数据类型的差别在于取值范围和精度, 数据的取值范围越大, 精度越高.

整型从低到高

char -> short -> int -> long -> long long

浮点型从低到高

float -> double -> long double

* 如果一个表达式中出现不同类型操作数的混合运算, 较低类型将自动向较高类型转换.
* 当表达式中含有浮点型操作数时, 所有操作数都将转换为浮点型
* 赋值运算的右值类型与左值类型不一致时, 将右值类型提升/降低为左值类型.
* 赋值运算右值超出了左值类型的表示范围, 把该右值阶段后赋给左值, 所得结果可能毫无意义.

#### 强制类型转换

有些类型的转换需要程序员显式指定.

语法`(目标类型)表达式`

* 如果使用强制转换， 说明程序员已有明确目的
* 如果转换的行为不符合规范，后果由程序员承担
* 如果采用了强制类型转换，编译的告警信息不再出现
* 类型转换运算符的优先级比较高

## 数据类型的别名

创建数据类型的别名有两个目的：

* 为名称复杂的类型创建别名，方便书写和记忆
* 创建与平台无关的数据类型，提高程序的兼容

实际开发中，创建别名的代码一般放在头文件中

语法：`typedef 数据类型名 别名;`

例子

```c++
#include <iostream>

using namespace std;

typedef unsigned int uint;

int main()
{
	uint a = 2147483647 + 100;
	cout << a << endl;
}
/*-------------------------------------------
输出：
2147483747

*/
```
