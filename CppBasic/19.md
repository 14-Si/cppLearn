# 继承

## 基本概念

语法：`class a : public b{...};`

不一定是public，也有其他方式

a是子类，b是父类

即使a中不编写任何新代码，也会拥有b所拥有的成员及函数

使用继承的场景：

* 如果新创建的类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承
* 当需要创建多个类时，如果他们拥有很多相似的成员变量或成员函数，可以将这些类共同的成员提取出来，定义为基类，然后从基类继承

## 类的继承方式

类成员的访问权限由高到低依次为：public，protected，private，public 成员在类外可以访问，private 成员只能在类的成员函数中访问

如果不考虑继承关系，protected 成员和 private 成员一样，类外不能访问。但是，当存在继承关系时，protected 和 private 就不一样了。基类中的 protected 成员可以在派生类中访问，而基类中 private 成员不能在派生类中访问

继承方式有三种：public（公有的），protected（受保护的），private（私有的）。它是可选的，如果不写，那么默认为 private。不同的继承方式决定了在派生类中成员函数中访问基类成员的权限不同

public继承：public成员和protected成员继承且权限不变，private不继承

protected继承：public成员和protected成员继承，权限为protected，private不继承

private继承：public成员和protected成员继承，权限为private，private不继承

* 基类成员在派生类中的访问权限不得高于继承方式中指定的权限，也就是说，继承方式中的public，protected，private是用来指明
* 如果希望基类的成员能够被派生类继承并且毫无障碍的地使用，那么这些成员只能声明为 public 或 protected
* 如果希望基类成员既不向外暴露，还能在派生类中使用，那么声明为 protected
* 在派生类中，可以通过基类的公有成员间接访问基类的私有成员
* 使用using关键字可以改变基类成员在派生类中的访问权限

注意：using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限

语法：

```
class a{
public:
	int ma = 0;
	int md = 3;
protected:
	int mb = 1;
private:
	int mc = 2;
};

class b: public a
{
public:
	using a::mb;
protected:
	using a::ma;
private:
	using a::md;
};
```

## 继承的对象模型

* 创建派生类对象时，先调用基类的构造函数，在调用派生类的构造函数
* 销毁派生类对象时，先调用派生类的析构函数，再调用基类的析构函数
* 创建派生类对象时只会申请一次内存，派生类对象包含了基类对象的内存空间，this指针一样
* 创建派生类对象时，先初始化基类对象，再初始化派生类对象
* 在VS中，用cl.exe可以查看类的内存模型
* 在C++中，不同的继承方式的访问权限只是语法上的处理
* 对派生类对象用sizeof得到的是基类所有成员（包括私有成员）+派生类对象所有成员的大小
* 对派生类对象用memset()会清空基类私有成员
* 用指针可以访问到基类中的私有成员（没有内存对齐，没有占位符）

> 查看对象内存布局的方法
>
> `cl 文件名 /d1 reportSingleClassLayout 类名`
>
> cl 命令环境变量
>
> 在PATH 环境中增加cl.exe 的目录
>

## 构造基类

派生类构造函数的要点如下：

1. 创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数
2. 如果没以指定基类构造函数，将使用基类的默认构造函数
3. 可以用初始化列表知名要使用的基类构造函数
4. 基类构造函数负责初始化被继承的数据成员；派生类的构造函数主要用于初始化新增的数据成员
5. 派生类的构造函数总是调用一个基类构造函数，包括拷贝构造函数

语法：

```
class b: public a
{
public:
	int numb;
	b(int na, int nb):a(na), numb(nb)
	{}
};
```



## 名字遮蔽与类作用域

如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，通过派生类对象或者在派生类的成员函数中使用该成员时，将使用派生类新增的成员，而不是基类的。

基类的成员函数和派生类的成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数

类是一种作用域，每个类都有他自己的作用域，在这个作用域内定义成员

在类的作用域之外，普通的成员只能通过对象（可以是对象本身，也可以是对象的指针或引用）来访问，静态成员可以通过对象访问，也可以通过类访问。

在成员名前面加类名和域解析符可以访问对象的成员

如果不存在继承关系，类名和域解析符可以省略不写

当存在继承关系时，基类的作用域嵌套派生类的作用域中。如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找；如果没有找到，则继续在基类作用域中查找

如果在成员的前面加上类名和域解析符，既可以直接使用该作用域的成员

```
class A{int numa;};
class B: public A{int numb;};
class C: public B{int numc;};
c.numc;
c.B::numb;
c.B::A::numa;
```



## 继承的特殊关系

派生类和基类之间有一些特殊关系

1. 如果继承方式是公有的，派生类对象可以使用基类成员
2. 可以把派生类对象复制给基类对象（包括私有成员），但是会舍弃非基类的成员
3. 基类指针可以在不进行显示转换的情况下指向派生类对象
4. 基类引用可以在不进行显示转换的情况下引用派生类对象

注意：

* 基类指针或引用只能用于调用基类方法，不能调用派生类方法
* 可以用派生类构造基类
* 如果函数的形参是基类，实参可以用派生类
* C++要求指针和引用类型与赋给的类型匹配，这一规则对于继承来说是例外的。但是，这种例外只是单项的，不可以将基类对象和地址赋给派生类的引用和指针（没有价值）

## 多继承与虚继承

多继承语法：

```
class 派生类名:[继承方式1] 基类名1, [继承方式2] 基类名2, ...
{
};
```

菱形继承：

```
class A{};
class B : public A{};
class C : public A{};
class D : public B, public C{};
```

这种情况下A会被D包含两次，分别作为B的基类的C的基类

相同属性可能会被重复继承，可以使用虚继承解决这种问题：

```
class A{};
class B : virtual public A{};
class C : virtual public A{};
class D : public B, public C{};
```

此时D里只有一个A

**不提倡使用多继承，只有在比较简单和不出现二义性的情况时才使用多继承，能用单一继承解决的问题就不要使用多继承**

如果继承的层次很多，关系很复杂，程序的编写，调试和维护工作都会变得很困难，由于这个原因，C++之后的很多面向对象语言都不支持多继承