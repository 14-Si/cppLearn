## 编译预处理

c++ 程序编译的过程：预处理 -> 编译（优化，汇编） -> 链接

预处理指令主要有以下三种

* 包含头文件`#include`
* 宏定义`#define（定义宏）, #undef（删除宏）`
* 条件编译`#ifdef, #ifndef`

1. 包含头文件

   \#include 包含头文件有两种方式
   
   * \#include <文件名>：直接从编译器自带的函数库目录中寻找文件
   * \#include "文件名"：先从自定义的目录中寻找文件，如果找不到，再从编译器自带的函数库目录中寻找
   
   \#include 也包含其他的文件，如.h, .cpp等文件
   
   C++ 98 标准后的头文件
   
   * C的标准库，老版本的有.h后缀，新版本没有.h后缀，增加了字符c的前缀，例如：老版本是stdio.h，新版本是cstdio，库中的内容是一样的，新老版本都可用，在程序中，不指定std命名空间也能使用库中的内容
   * C++ 的标准库：老版本有.h后缀，新版本没有.h后缀，例如：老版本是iostream.h，新版本是iostream，老版本已弃用，只能用新版本。在程序中，必须指定std命名空间才能使用库中的内容
   
   **注意：用户自定义的头文件还是用.h为后缀**
   
2. 宏定义指令

   无参数的宏：`#define 宏名 宏内容`

   有参数的宏：`#define MAX(x, y) ((x) < (y) ? (y) : (x)) `

   编译的时候，编译器把程序中的宏名用宏内容替换，是为宏展开

   宏可以只有宏名，没有后面的宏内容

   在 C++ 中，内联函数可替代有参数的宏，效果更好

   C++ 中常用的宏：

   * 当前源代码文件名：`__FILE__`
   * 当前源代码函数名：`__FUNCTION__`
   * 当前源代码行号：`__LINE__`
   * 编译的日期：`__DATE__`
   * 编译的时间：`__TIME__`
   * 编译的时间戳：`__TIMESTAMP__`
   * 当用C++编译程序时，宏_cplusplus就会被定义

3. 条件编译

   最常用的两种：#ifdef, #ifndef

   ```
   #ifdef 宏名
   	程序一
   #else
   	程序二
   #endif
   ```

   含义：如果#ifdef后面的宏名已存在，则使用程序一，否则使用程序二

   \#ifndef如果宏名不存在，则用程序一，否则使用程序二

4. 解决头文件中代码重复包含的问题

   在C++ 中，在使用预编译指令`#include`的时候，为了防止头文件被重复包含，有两种方式

   第一种：用#ifndef指令

   ```
   #ifndef _CLASS_A_
   	#define _CLASS_A_
   	// 代码
   #endif
   ```

   第二种：把#pragma once 指令放在文件开头

   \#ifndef方式收C++语言标准的支持，不受编译器的任何限制；而#pragma once方式有些编译器不支持

## 编译和链接

1. 源代码的组织

   头文件：#include头文件，函数的声明，结构体的声明，类的声明，模板的声明，内联函数，#define和const定义的常量等

   源文件：函数的定义，类的定义，模板具体化的定义

   主程序：主程序负责实现框架和核心流程，把需要用到的头文件用#include包含进来

2. 编译预处理

   * 处理#include 头文件包含指令
   * 处理条件编译指令
   * 处理宏定义
   * 为代码添加行号，文件名和函数名
   * 删除注释
   * 保留部分#pragma编译指令

3. 编译

   将预处理生成的文件，经过词法分析，语法分析，语义分析以及优化和汇编后，编译成若干个目标文件

4. 链接

   将编译后的目标文件，以及他们所需要的库文件连接在一起，形成一个整体

5. 更多细节

   * 分开编译的好处：每次只编译修改过的源文件，然后再链接，效率最高
   * 编译单个cpp文件时，必须要让编译器知道名称的存在，否则会出现找不到标识符的错误
   * 编译单个cpp文件时，编译器只需要知道名称的存在，不会把它们的定义一起编译
   * 如果函数和类的定义不存在，编译不会报错，但链接会出现无法解析的外部命令
   * 链接的时候，变量，函数和类的定义只能有一个，否则会出现重定义的错误
   * 把变量，函数和类的定义放在h文件中是不规范的做法，如果h被多个cpp包含，会出现重定义
   * 用include包含cpp文件时不规范的做法，原理同上
   * 尽可能不使用全局变量，如果一定要用，要在h文件中声明（需要加extern），在cpp中定义
   * 全局的const常量在头文件中声明和定义（const常量尽在单个文件内有效）
   * h重复包含的处理方法只对单个cpp文件有效，不是整个项目
   * 函数模板和类模板的声明和定义可以分开书写，但他们的定义并不是真实的定义，只能放在h文件中；函数模板和类模板的具体化版本的大妈时真实的定义，所以放在cpp文件中
   * Linux下C++编译和链接的原理与VS一样

## C++ 命名空间

在实际开发中，较大型的项目会使用大量的全局名称，如类，函数，模板，变量等，很容易出现名字冲突的情况

命名空间分割了全局空间，每个命名空间是一个作用域，防止名字冲突

#### 语法：

创建命名空间：

```
namespace 命名空间
{
	//声明和定义
}
```

创建命名空间的别名：

```
namespace 别名 = 原名
```

#### 使用命名空间

在同一命名空间内的名字可以直接访问，该命名空间之外的代码则必须明确指出命名空间

1. 运算符::

   语法：`命名空间::名字`

   简单明了，且不会造成冲突

2. using 声明

   语法：`using 命名空间::名字`

   用using声明后，就可以进行直接使用名称

   如果该生命区域有相同的名字，则会报错

3. using 编译指令

   语法：`using namespace 命名空间`

   using 编译指令将使整个命名空间中的名字可用。如果声明区域有相同的名字，局部版本将隐藏命名空间中的名字，不过，可以使用域名解析符使用命名空间中的名称

4. 注意事项

   * 命名空间是全局的，可以分布在多个文件中
   * 命名空间可以嵌套
   * 在命名空间中声明变量，而不是使用外部全局变量和静态全局变量
   * 对于 using 声明，首选将其作用域设置为局部而不是全局
   * 不要在头文件中使用using编译指令，如果非要使用，应将它放在所有的#include之后
   * 匿名的命名空间，从创建的位置到文件结束有效

