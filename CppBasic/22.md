# C++ 泛编程

## 自动推导类型

在C语言和C++98中，auto关键字用于修饰变量（自动存储的局部变量）

在 C++ 11中，赋予了auto全新的含义，不在用于修饰的变量，而是作为一个类型指示符，指示编译器在编译时推导 auto 声明的变量的数据类型

在 Linux 平台下，编译需要加 `-std=c++11`参数

注意：

1. auto 变量必须在定义时初始化
2. 右值可以是具体的数值，也可以是表达式和函数的返回值等
3. auto 不能作为函数的形参类型
4. auto 不能直接声明数组
5. auto 不能定义类的非静态成员变量

**不要滥用auto，auto在编程时真正的用途如下：**

1. 代替冗长复杂的变量声明
2. 在模板中，用于声明依赖模板参数的变量
3. 函数模板依赖模板参数的返回值
4. 用于 lambda 表达式中

## 函数模板

### 基本概念

函数模板是通用的函数描述，使用任意类型（泛型）来描述函数

编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，声称该类型的函数定义

生成函数定义的过程被称为实例化

创建交换两个变量的函数模板：

```
template <typename T>
void swap(T &a, T &b)
{
	T tmp = a;
	a = b;
	b = tmp;
}
```

在 C++ 98 添加关键字 typename 之前，C++使用关键字 class 来创建模板

如果考虑向后兼容，函数模板应该使用 typename而不是class

函数模板实例化可以让编译器自动推导，也可以在调用的代码中显式地指定

### 注意事项

1. 可以为类成员函数创建模板，但不能是虚函数和析构函数
2. 使用函数模板时，必须明确数据类型，确保实参与函数模板能配上
3. 使用函数模板时，推导的数据类型必须适应函数模板中的代码
4. 使用函数模板时，如果是自动类型推导，不会发生隐式类型转换，如果显示指定了函数模板的数据类型，可以发生隐式类型的转换
5. 函数模板支持多个通用数据类型的参数`template <typename T1, typename T2>`
6. 函数模板支持重载，可以有非通用数据类型的参数

### 具体化

可以提供一个具体化的函数定义，当编译器找到与蛤属调用匹配的具体化定义时，将使用该定义，不在寻找模板

具体化（特例化，特化）的语法：

```
template<> void 函数模板名<数据类型>(参数列表)

template<> void 函数模板名(参数列表)
{
}
```

对于给定的函数名，可以有普通函数，函数模板和具体化的函数模板，以及它们的重载版本

1. 具体化优先于常规模板，普通函数优先于具体化和常规模板
2. 如果希望使用函数模板，可以用空模板参数强制使用函数模板
3. 如果函数模板能产生更好的匹配，将优先于非模板函数

### 分文件编写

函数模板只是函数的描述，没有实体，创建函数模板的代码放在头文件中

函数模板的具体化有实体，编译的原理和普通函数一样，所以，声明放在头文件中，定义放在源文件中

### C++ 11 扩展

#### decltype 关键字

在C++ 11 中，decltype操作符用于查询表达式的数据类型

语法：`decltype(expression) var;`

decltype 分析表达式并得到它的类型，不会计算执行表达式。函数调用也是一种表达式，因此不必担心还在使用decltype时执行了函数

decltype推导规则：

1. 如果expression是没有用括号括起来的标识符，则var的类型与该标识符的类型形同，包括const等限定符
2. 如果expression是函数调用，则var的类型与函数的返回值类型相同（函数不能返回void，但可以返回void*）
3. 如果expression是左值（能取地址），或者用括号括起来的标识符，那么var是expression的引用
4. 如果上面的条件都不满足，则var的类型与expression的类型相同

如果需要多次使用decltype，可以结合typedef和using

#### 函数后置返回类型

`int func(int a, int b)`

等同于

`auto func(int a, int b) -> int`

将返回类型移到了函数声明的后面。

auto 是一个占位符（C++ 11 给auto 新增的角色），为函数返回值占了一个位置。

这种语法也可以用于函数定义：

`auto func(int a, int b) -> int{}`

#### C++14的auto关键字

C++14标准对函数返回类型推到规则做了优化，函数的返回值可以用auto，不必尾随返回类型。

## 类模板

### 基本概念

类模板是通用类的描述，使用任意类型（泛型）来描述类的定义

使用类模板的时候，制定具体的数据类型，让编译器生成该类型的类定义

语法：

```
template<class T>
class 类模板名
{
	类的定义
};
```

注意：

1. 在创建对象时，必须指明具体的数据类型
2. 使用类模板时，数据类型必须适应类模板中的代码
3. 类模板可以为通用参数指定默认的数据类型（C++11 标准的函数模板也可以）
4. 类的成员函数可以在类外实现
5. 可以用 new 创建模板对象
6. 在程序中，模板类的成员函数使用了才会创建

### 示例：栈

```
template <class T>
class my_stack
{
private:
    T *item;
    int stacksize;
    int top;

public:
    my_stack(int size) : stacksize(size), top(0)
    {
        item = new T[size];
    }
    ~my_stack()
    {
        delete[] item;
        item = nullptr;
    }
    bool isempty()
    {
        return top == 0;
    }
    bool isfull()
    {
        return top == stacksize;
    }
    bool push(const T &data)
    {
        if (top < stacksize)
        {
            item[top++] = data;
            return true;
        }
        return false;
    }
    bool pop(T &data)
    {
        if (top > 0)
        {
            data = item[--top];
            return true;
        }
        return false;
    }
};
```

### 示例：数组

```
template <class T, int len = 10>
class my_array
{
private:
    T item[len];

public:
    my_array() {}
    ~my_array() {}
    T &operator[](int cnt)
    {
        return item[cnt];
    }
    const T &operator[](int cnt) const
    {
        return item[cnt];
    }
};
```

类模板可以有非通用类型参数

1. 通常是整型（C++20标准可以用其他）
2. 实例化模板时必须用常量表达式
3. 模板中不能修改参数的值

优点：在栈上分配内存，易维护，执行速度快，适合小型数组

缺点：在程序中，不同的非通用类型参数将导致编译器生成不同的类

构造函数的方法更通用，因为数据的大小是类的成员（而不是硬编码），可以创建数组大小可变的类

### 嵌套和递归使用模板类

容器中有容器的情况下可以使用嵌套和递归使用模板类，比如数组中有栈

### 模板类具体化

模板类具体化（特化，特例化）有两种：完全具体化和部分具体化

具体化程度高的类优先于具体化程度低的类，具体化的类优先于没有具体化的类

### 模板类与继承

1. 模板类继承普通类        `template<class T1, class T2> class b : public a{};`
2. 普通类继承模板类的实例版本        `class a : public b<int, string>{};`
3. 普通类继承模板类    `template<class T1, class T2> class a : public b<T1, T2>{};`
4. 模板类继承模板类    `template<class T1, class T2, class T3> class a : public b<T1, T2>{};`
5. 模板类继承模板参数给出的基类    `template<class T> class a : public T{};`

### 模板类与函数

模板类可以用于函数的返回值和参数，有三种形式：

1. 普通函数，参数和返回值是模板类的实例化版本
2. 函数模板，参数和返回值是某种模板类
3. 函数模板，参数和返回值是任意类型（支持普通类和模板类和其他类型）

### 模板类与友元

模板类的友元函数有三类

1. 非模板友元：友元函数不是模板函数，而是利用模板类参数生成的函数，只能在类内实现
2. 约束模板友元：模板类实例化时，每个实例化的类对应一个友元函数
3. 非约束模板友元：模板类实例化时，如果实例化了n个类，也会实例化n个友元函数，每个实例化的类都拥有n个友元函数

